/*
 * 
 * @author Zikang Sheng
 * I pledge my honor that I have abided by the Stevens Honor System.
 * 04/21/2020
 *
 */

import java.util.Random;
import java.util.Stack;

public class Treap<E extends Comparable<E>> {
	private static class Node<F>{
		//Data fields
		public F data;
		public int priority;
		public Node<F> left;
		public Node<F> right;
		
		//Constructor
		public Node(F data, int priority) {
			if (data==null) {
				throw new IllegalArgumentException("Data cannot be null!");
			}
			this.data = data;
			this.priority = priority;
			left = null;
			right = null;
		}
		
		//Methods
		/**
		 * Performs a right rotation.
		 * @return new root
		 */
		Node<F> rotateRight() {
			Node<F> pivot = this.left;
			Node<F> temp = this.left.right;
			pivot.right = this;
			this.left = temp;
			return pivot;
		}
		
		/**
		 * Performs a left rotation.
		 * @return new root
		 */
		Node<F> rotateLeft() {
			Node<F> pivot = this.right;
			Node<F> temp = this.right.left;
			pivot.left = this;
			this.right = temp;
			return pivot;
		}
		
		public String toString() {
			return "(key=" + data + ", priority=" + priority + ")";
		}
	}
	
	//Data fields
	private Random priorityGenerator;
	private Node<E> root;
	
	//Constructors
	public Treap() {
		priorityGenerator = new Random();
		root = null;
	}
	
	public Treap(long seed) {
		priorityGenerator = new Random(seed);
		root = null;
	}
	
	//Methods
	
	/**
	 * Helper function for method add(E key, int priority).
	 * @param stack
	 * @return new root
	 */
	private Node<E> reheap(Stack<Node<E>> stack){
		Node<E> current = stack.pop();
		while (!stack.empty()) {
			Node<E> parent = stack.peek();
			if (current.priority>parent.priority) {
				int n = current.data.compareTo(parent.data);
				if (n>0) {
					parent.rotateLeft();
				}
				else {
					parent.rotateRight();
				}
				Node<E> temp = stack.pop();
				if (stack.size()>=1) {
					parent = stack.peek();
					if (parent.left==temp)
						parent.left = current;
					else
						parent.right = current;
				}
			}
			else {
				current = stack.pop();
			}
		}
		return current;
	}
	
	/**
	 * To insert the given element into the tree, create a new node containing key as its data and a random priority generated by priorityGenerator.
	 * @param key
	 * @return true if the node is added, otherwise return false
	 */
	boolean add(E key) {
		int priority = priorityGenerator.nextInt();
		return add(key, priority);
	}
	
	boolean add(E key, int priority) {
		Node<E> current = root;
		if (current==null) {
			root = new Node<E>(key, priority);
			return true;
		}
		
		Stack<Node<E>> stack = new Stack<Node<E>>();
		stack.push(current);
		while (current.left!=null || current.right!=null) {
			int n = current.data.compareTo(key);
			if (n>0) {
				if (current.left==null) {
					break;
				}
				current = current.left;
				stack.push(current);
			}
			else if (n<0) {
				if (current.right==null) {
					break;
				}
				current = current.right;
				stack.push(current);
			}
			else {
				return false;
			}
		}
		int n = current.data.compareTo(key);
		if (n>0) {
			current.left = new Node<E>(key, priority);
			stack.push(current.left);
		}
		else if (n<0){
			current.right = new Node<E>(key, priority);
			stack.push(current.right);
		}
		else {
			return false;
		}
		root = reheap(stack);
		return true;
	}
	
	/**
	 * Deletes the node with the given key from the treap.
	 * @param key
	 * @return true if the node is deleted, otherwise return false
	 */
	boolean delete(E key) {
		if (!find(key)) {
			return false;
		}
		if (root.left==null && root.right==null) {
			root = null;
			return true;
		}
		
		Node<E> current = root;
		Stack<Node<E>> stack = new Stack<Node<E>>();
		stack.push(current);
		while (!current.data.equals(key)) {
			int n = current.data.compareTo(key);
			if (n>0) {
				current = current.left;
				stack.push(current);
			}
			else {
				current = current.right;
				stack.push(current);
			}
		}
		
		Node<E> target = stack.pop();
		if (stack.empty()) {
			Node<E> temp = null;
			if (target.right==null) {
				temp = target.rotateRight();
			}
			else if (target.left==null) {
				temp = target.rotateLeft();
			}
			else {
				if (target.left.priority>target.right.priority) {
					temp = target.rotateRight();
				}
				else {
					temp = target.rotateLeft();
				}
			}
			stack.push(temp);
			root = temp;
		}
		
		Node<E> parent = stack.peek();
		while (target.right!=null || target.left!=null) {
			Node<E> temp = null;
			if (target.right==null) {
				temp = target.rotateRight();
			}
			else if (target.left==null) {
				temp = target.rotateLeft();
			}
			else {
				if (target.left.priority>target.right.priority) {
					temp = target.rotateRight();
				}
				else {
					temp = target.rotateLeft();
				}
			}
			stack.push(temp);
			if (parent.left==target) {
				parent.left = temp;
			}
			else {
				parent.right = temp;
			}
			parent = stack.peek();
		}
		if (parent.left==target) {
			parent.left = null;
		}
		else {
			parent.right = null;
		}
		return true;
	}
	
	/**
	 * Helper function for method find(E key).
	 * @param root
	 * @param key
	 * @return true if the node is found, otherwise return false
	 */
	private boolean find(Node<E> root, E key) {
		if (root==null) {
			return false;
		}
		if (root.data.equals(key)) {
			return true;
		}
		return find(root.left, key) || find(root.right, key);
	}
	
	/**
	 * Finds a node with the given key in the treap.
	 * @param key
	 * @return true if the node is found, otherwise return false
	 */
	boolean find(E key) {
		return find(root, key);
	}
	
	/**
	 * Helper function for toString method.
	 * @param current
	 * @param i
	 * @return string
	 */
	private StringBuilder toString(Node<E> current, int i) {
		StringBuilder r = new StringBuilder() ;
		for (int j=0; j<i; j++) {
			r.append("\t");
		}
		
		if (current==null) {
			r.append("null\n");
		} 
		else {
			r.append(current.toString()+"\n");
			r.append(toString(current.left,i+1));
			r.append(toString(current.right,i+1));
			
		}
		return r;
		
	}
	
	public String toString() {
		return toString(root,0).toString();
	}
	
}
